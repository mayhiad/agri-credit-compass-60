
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import "https://deno.land/x/xhr@0.1.0/mod.ts";
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.38.4';
import OpenAI from 'https://esm.sh/openai@4.38.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

const openaiApiKey = Deno.env.get('OPENAI_API_KEY');
const supabaseUrl = Deno.env.get('SUPABASE_URL');
const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');

const supabase = createClient(supabaseUrl, supabaseServiceKey);
const openai = new OpenAI({
  apiKey: openaiApiKey,
  defaultHeaders: { 'OpenAI-Beta': 'assistants=v2' }
});

// R√©szletes diagnosztikai logging hozz√°ad√°sa
async function processDocumentWithOpenAI(fileBuffer: ArrayBuffer, fileName: string, userId: string) {
  console.log(`üîç Dokumentum feldolgoz√°s megkezd√©se: ${fileName}`);
  console.log(`üì¶ Dokumentum m√©rete: ${fileBuffer.byteLength} b√°jt`);

  try {
    // F√°jl felt√∂lt√©s r√©szletes logol√°sa
    const file = await openai.files.create({
      file: new File([fileBuffer], fileName),
      purpose: "assistants"
    });
    console.log(`üì§ F√°jl sikeresen felt√∂ltve. File ID: ${file.id}`);

    // Asszisztens l√©trehoz√°s diagnosztikai adatokkal
    const assistant = await openai.beta.assistants.create({
      name: "SAPS Dokumentum Elemz≈ë Diagnosztika",
      instructions: `
        DIAGNOSZTIKAI MINTA:
        R√©szletes JSON kibont√°s a dokumentumb√≥l:
        {
          "debug": {
            "fileSize": "${fileBuffer.byteLength}",
            "fileName": "${fileName}"
          },
          "applicantName": "K√©relmez≈ë teljes neve",
          "cultures": [
            {
              "name": "Kult√∫ra neve",
              "hectares": "Ter√ºlet nagys√°ga",
              "detailedInfo": "Opcion√°lis r√©szletek"
            }
          ]
        }
      `,
      tools: [{ type: "retrieval" }],
      model: "gpt-4o",
      file_ids: [file.id]
    });
    console.log(`ü§ñ Asszisztens l√©trehozva. ID: ${assistant.id}`);

    // Thread √©s √ºzenet l√©trehoz√°s diagnosztikai c√©llal
    const thread = await openai.beta.threads.create();
    console.log(`üìù Thread l√©trehozva. ID: ${thread.id}`);

    await openai.beta.threads.messages.create(thread.id, {
      role: "user",
      content: `
        DIAGNOSZTIKAI FELDOLGOZ√ÅS:
        1. Olvasd ki a dokumentum √∂sszes lehets√©ges adat√°t
        2. R√©szletes JSON form√°tum
        3. Debug inform√°ci√≥k felt√ºntet√©se
      `,
      file_ids: [file.id]
    });

    // Futtat√°s √©s r√©szletes √°llapotk√∂vet√©s
    const run = await openai.beta.threads.runs.create(thread.id, {
      assistant_id: assistant.id
    });

    console.log(`üèÉ Feldolgoz√°s elind√≠tva. Run ID: ${run.id}`);

    // Futtat√°s √°llapot√°nak r√©szletes nyomonk√∂vet√©se
    let runStatus: string;
    const maxAttempts = 10;
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
      const retrievedRun = await openai.beta.threads.runs.retrieve(thread.id, run.id);
      runStatus = retrievedRun.status;
      
      console.log(`üïí ${attempt}. pr√≥b√°lkoz√°s - St√°tusz: ${runStatus}`);

      if (runStatus === 'completed') break;
      if (runStatus === 'failed') {
        console.error("‚ùå Feldolgoz√°s sikertelen", retrievedRun);
        throw new Error(`Feldolgoz√°s sikertelen: ${retrievedRun.last_error?.message}`);
      }

      await new Promise(resolve => setTimeout(resolve, 3000)); // Hosszabb v√°rakoz√°si id≈ë
    }

    // √úzenetek lek√©r√©se r√©szletes logol√°ssal
    const messages = await openai.beta.threads.messages.list(thread.id);
    const assistantMessages = messages.data.filter(msg => msg.role === 'assistant');
    
    console.log(`üì¨ √ârkezett asszisztensi √ºzenetek: ${assistantMessages.length}`);

    const extractedContent = assistantMessages
      .map(msg => msg.content[0].type === 'text' ? msg.content[0].text.value : null)
      .filter(Boolean);

    console.log("üìã Nyers kivont tartalom:", extractedContent);

    // Robusztus JSON kibont√°s
    const jsonData = extractedContent.reduce((acc, content) => {
      try {
        const jsonMatch = content.match(/```json\s*([\s\S]*?)\s*```/);
        const parsedJson = jsonMatch 
          ? JSON.parse(jsonMatch[1]) 
          : JSON.parse(content);
        return { ...acc, ...parsedJson };
      } catch (parseError) {
        console.warn("‚ùó JSON parsing hiba:", parseError);
        return acc;
      }
    }, {});

    console.log("üîç Feldolgozott JSON:", jsonData);

    // Diagnosztikai adatok ment√©se Supabase-be
    await supabase.from('diagnostic_logs').insert({
      user_id: userId,
      file_name: fileName,
      file_size: fileBuffer.byteLength,
      extraction_data: jsonData,
      created_at: new Date().toISOString()
    });

    console.log("‚úÖ Diagnosztikai adatok sikeresen mentve");

    return jsonData;

  } catch (error) {
    console.error("üö® Teljes feldolgoz√°si hiba:", error);
    throw error;
  }
}

serve(async (req) => {
  if (req.method === 'OPTIONS') return new Response(null, { headers: corsHeaders });

  try {
    const formData = await req.formData();
    const file = formData.get('file') as File;
    
    if (!file) throw new Error('Nem √©rkezett f√°jl');

    const fileBuffer = await file.arrayBuffer();
    const processedData = await processDocumentWithOpenAI(fileBuffer, file.name, 'debug_user');

    return new Response(JSON.stringify(processedData), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });
    
  } catch (error) {
    console.error("üî• V√©gs≈ë hibakezel√©s:", error);
    return new Response(JSON.stringify({ 
      error: error.message, 
      details: error.toString() 
    }), { 
      status: 500, 
      headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
    });
  }
});
